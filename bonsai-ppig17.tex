\documentclass{ppig}
\usepackage{epsfig, graphicx} % support for image encoding and manipulation
\usepackage{ucs} % support for using UTF-8 as input encoding in LaTeX
\usepackage[utf8x]{inputenc} % required for UTF-8 support with ucs.sty
\usepackage{tabularx, multirow, booktabs} % support for high-quality tables

% The titlebox defines how much vertical space is given for
% the authors' list. If you need extra space to show all the
% authors, uncomment the line below and increase the value. Please
% do not make the titlebox smaller than the original size of 5cm.
%\setlength\titlebox{5cm}

\title{Problem-Solving in Programming: A Metacognitive Examination of IDE Design}

% List the authors like you would in a table.
% The \And command creates another author's column. Use it after the
% details of one author to separate them from the following author horizontally.
% The \AND command creates a new "row" of authors and it should be used
% when the authors don't fit on the same line. You may have to increase
% the titlebox so that the author's don't overlap with the abstract.
\author{Nicholas Nelson \\
  Electrical Engineering \&\\ Computer Science \\
  Oregon State University \\
  nelsonni@oregonstate.edu \\
  \And
  Anita Sarma \\
  Electrical Engineering \&\\ Computer Science \\
  Oregon State University \\
  Anita.Sarma@oregonstate.edu \\
  \And
  Andr√© van der Hoek \\
  Department of Informatics \\
  University of California, Irvine \\
  andre@ics.uci.edu
}
  
\date{\today}

\newcommand{\nameUI}{\textit{<Insert Name>} UI}

% Packages and macros for editorial purposes. Not required for submission.
\usepackage{color}
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{ballblue}{rgb}{0.13, 0.67, 0.8}
\definecolor{aoblue}{rgb}{0.0, 0.0, 1.0}
\newcommand{\bold}[1]{\textit{\textbf{\color{aoblue}#1}}}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage{enumitem}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}

Programming is more than generating, testing, and maintaining code.
Programming is fundamentally an extension of cognitive problem-solving skills applied to computational problems.
Contemporary IDEs natively support the code-centric aspects of programming, but forego supporting many of the cognitive aspects of problem-solving that do not directly involve code.
We propose that IDEs should support the entire gamut of problem-solving activities during programming, and that this requires a re-examination and redesign of the IDE user interface.
To this end, we focus this paper on actions that developers take when developing strategies to address a programming task.
In particular, we look at the actions of: (1) articulating \& refining alternatives, (2) understanding \& assessing alternatives, and (3) recombining aspects of alternatives.
Based upon our observations, we propose a new user interface for IDEs which enables previously underrepresented aspects of problem-solving; specifically addressing the disparity in support for these three aspects. 
\end{abstract}

\section{Introduction}
\bold{Scenario to illustrate programming as problem-solving\\}
Imagine a scenario in which Sally, a junior developer, is tasked with updating a specific feature to take advantage of new data storage architecture that has been implemented for a large-scale software project.
Since Sally's employer is a small software company, individual developers are asked to take ownership of individual features and shepherd them from design to completion.

Sally begins her project by logging into the company's issue tracker and assigning the associated issue to herself.
She also downloads and opens several documents included with the feature issue; a PDF document containing sketches and notes from the design team, a list of requirements from the marketing team, and another PDF document containing an estimated timeline from the project manager assigned to this project.
Before beginning to write code, Sally decides that she needs to understand the area of code she will be modifying and drafting a plan for how to implement those modifications.
To accomplish these sub-tasks, she spends a day reading through the code using an IDE and sketching potential implementations on a piece of paper using shapes and arrows to represent different abstractions for the code.
After exhausting her initial ideas, she works through some of the more promising sketches to determine the feasibility of each alternative.

The sketches and ideas that appear to have the most strengths (and inversely, the least weaknesses) for this specific situation will require modifying certain portions of the core architecture of the software.
Since changes to the core architecture will affect the rest of the development team, and could potentially interrupt development in other areas of the project, Sally sends emails to the senior developer on her team and the project manager.
After several rounds of emails, and one project meeting organized by the project manager, Sally has notes scribbled on several pieces of paper, a trail of emails between different stakeholders, and a verbally-communicated history of why and how the code is organized the way it is today.

Converting all of the information contained within these different artifacts into useful bits of code takes requires combining different aspects into a single solution.
Sally is able to complete her task and submit her feature code, but not without significant effort to remain organized and the ability to bring different problem-solving abilities to bear on both code and non-code related sub-tasks.
Because her IDE only targets code artifacts in a linear manner, Sally is unable to leverage tool support for most of the tasks outlined in this scenario.

\section{Programming as Problem-Solving}

\bold{Introduction to our model of programming as problem-solving, and the mapping between problem-solving psychology and programming tasks\\}

Examining the disparate and disbursed nature of artifacts in Sally's situation, which exemplifies a typical situation among programmers, we can quickly see that a new way of understanding the nature of programming is needed.
We propose using problem-solving as a lens to examine programming tools, specifically IDEs, to assist in qualifying which aspects of programming are not being supported and to determine how to address those gaps.

In a normal software development cycle, programmers are known to create all sorts of auxiliary non-code artifacts~\cite{cherubini2007whiteboard}.
Programmers are also known to organize these artifacts into structures that are relevant to the particular task(s) they are currently working on~\cite{baltes2016empirical}.
Also, programmers are known to not pursue a single solution, but to generally approach a task by exploring (either mentally or externalized) multiple alternative solutions~\cite{madeyski2017experimentation}.
These actions can be classified as \textit{representing relevant information}, \textit{contextualizing information}, and \textit{generating alternatives} (respectively) when examined as problem-solving actions.
And further, these actions can be grouped into the problem-solving activities of \textit{externalizing thoughts \& ideas} and \textit{developing strategies} when generalized according to cognitive psychology~\cite{mayer1992thinking}.

\begin{table}[!htbp]
\caption{Activities and Actions of Programming as Problem-Solving}
\label{matrix}
\centering
\begin{tabular}{|c|l|}
	\hline
	\multicolumn{1}{|c|}{\textbf{Activity}} 
	& \multicolumn{1}{c|}{\textbf{Action}}\\\hline
	\multirow{5}{*}{Understanding the situation} 
	& Identifying goals \\\cline{2-2}
	& Recalling prior knowledge \\\cline{2-2}
	& Constructing models \\\cline{2-2}
	& Interpreting code artifacts \\\cline{2-2}
	& Filling knowledge gaps \\\hline
	\multirow{3}{*}{Externalizing thoughts \& ideas} 
	& Representing relevant information \\\cline{2-2}
	& Contextualizing information \\\cline{2-2}
	& Preserving contextual information \\\hline
	\multirow{4}{*}{Developing strategies} 
	& Generating alternatives \\\cline{2-2}
	& Articulating and refining alternatives \\\cline{2-2}
	& Understanding and assessing alternatives \\\cline{2-2}
	& Recombining aspects of alternatives \\\hline
	\multirow{3}{*}{Enacting change} 
	& Translating strategies to actions \\\cline{2-2}
	& Tracking progress \\\cline{2-2}
	& Evaluating and assessing change \\\hline
	\multirow{5}{*}{Collaborate} 
	& Feedback solicitation \\\cline{2-2}
	& Team work \\\cline{2-2}
	& Group think \\\cline{2-2}
	& Leveraging group knowledge \\\cline{2-2}
	& Synchronization \\\hline
	\multirow{2}{*}{Retrospect} 
	& Reflect on work \\\cline{2-2}
	& Preserve work \\\hline
\end{tabular}
\end{table}

In many cases, the act of writing code is a small part of the larger activity that goes into solving computational problems.
Programming is not merely about language syntax and semantics~\cite{loksa2016programming}.
There are aspects of software development that involve the creation, use, and preservation of artifacts that are devoid of code.
These artifacts have a profound impact on the act of programming, the code that results from programming, and whether a developer is successful in addressing a target problem.

Using literature from cognitive psychology, human-computer interaction, and psychology in programming, we have developed Table~\ref{matrix} to represent general problem-solving activities (column \textit{Activity}) and the corresponding programming actions (column \textit{Action}).
We propose that this table accommodates aspects of programming that would otherwise be obfuscated by the focus of modern IDEs on elevating code artifacts to be the only first-class citizens.

Although not all actions are taken for every problem, across multiple problems and development sessions, these actions are continually employed by programmers.
Therefore, to enable programmers to solve increasingly complex problems, their tools should accommodate the full gamut of the problem-solving process.
As it currently stands, however, the UI for modern IDEs are built around the code-centric concept and cannot be easily altered.

\section{Challenges}
\bold{Discussion of challenges associated with current IDEs/problem-solving in programming\\}
Modern IDEs adhere to some common design principles: clarity, consistency, progressive disclosure, and strong visual hierarchies.
Clarity to allow users to understand what they are interacting with, predict what will happen when they use it, and then successfully interact with it.
Consistent in both the design of elements shown to users and the behaviors associated with those elements.
Showing only what is necessary on each screen, and allowing users to progressively expose additional features as necessary when workflows dictate that such actions could be necessary.
Strong visual clues that direct user's gaze and interactions to follow the hierarchy of visual elements presented on a screen.
Modern IDEs seek to provide advanced features only when needed and to allow users to focus on the development of code as their primary activity.
This assumption leads to workflows and uses cases that favor code-centric design, and askew activities and interactions with non-code artifacts to other applications.

\bold{TODO: Add references to IDEs for Novices, Lighthouse, ...\\}
Previous work on alternative UI models for IDEs have focused on expanding the interface to allow more dynamic interactions for code comprehension and orientation.
Bragdon et al. proposed a user interface comprised of lightweight, editable fragments called bubbles, which form concurrently visible working sets in an interface called Code Bubbles~\cite{bragdon2010bubbles}.
DeLine et al. explored leveraging spatial memory to keep developers oriented by providing an infinite zoomable surface for software development, called Code Canvas~\cite{deline2010canvas}.
And combining efforts, the Code Bubbles team at Brown University and the Code Canvas team at Microsoft Research jointly created Debugger Canvas which provides collections of code bubbles on a two-dimensional pan-and-zoom interface~\cite{deline2012debugger}.
The interface models developed by these teams provide both theoretical and practical experience into alternative UI designs that help to break the mold of the ``bento-box'' model of IDEs.
Henley and Fleming similarly examined the tedious nature of navigating large information spaces and sought to reduce this burden for developers through a code editor UI that consists of a patch grid and a ribbon for navigating quickly through sets of code~\cite{henley2014patchworks}.
We seek to take these experiments a step further and examine whether combining the new paradigm of programming as problem-solving and non-code centric UI design can further enable developers in developing solutions to computational problems.

\section{\nameUI{}}
\bold{Present and discuss our envisioned solution\\}
To address these challenges, we present \nameUI{}, an alternative user interface for integrated development environments that support the gamut of problem-solving activities in software development.
The goal of \nameUI{} is to offer developers: a cards-based interface for organizing and searching artifacts based on changing requirements, and an extensible catalog of card UI elements that can easily accommodate new use-cases and behaviors.
This approach provides developers with a framework for adapting their IDE to suit their desired configuration, instead of adapting their processes to compensate for it.
\begin{figure}[h!]
	\caption{\nameUI{} mockup}
	\label{mockup}
	% trim={<left> <lower> <right> <upper>}
	\fbox{\includegraphics[trim={0.6cm 3.2cm 0.5cm 0.6cm},clip,width=\textwidth]{Mockup-9}}
	\vspace*{-1.5\baselineskip}
\end{figure}

\bold{WARNING! The text below no longer correctly reflects either the Sally example situation, or the cards listed in the mockup image above.}\\
Figure~\ref{mockup} displays a high-fidelity mockup of the previous scenario in which Sally is developing a solution to migrate a leaderboard feature to a new shared platform.
She initially creates three sketch cards that contain flow diagrams of three alternative solutions for the problem (cards \texttt{C1-C3}).
Once she has stopped creating new alternatives, she begins to examine the cards already placed on her workspace and decides that the solution on card \texttt{C3} might not be feasible for this particular situation.
To verify this assumption, she opens a code editor card (\texttt{C4}) and begins writing exploratory code in order to validate that this solution does not meet all of the task requirements.
However, during this exploratory development session she realizes that there is another potential solution that could be better than any of her previous alternatives.
She creates another sketch card (\texttt{C5}) to contain that new idea she had, and then a code editor card (\texttt{C6}) to explore the implementation.
After she feels comfortable with this latest solution, she contacts the senior developer on her team via an instant messaging (IM) card (\texttt{c7}) that integrates her Slack conversation into the IDE workspace and shares cards \texttt{C5} and \texttt{C6} to discuss her proposed changes.
The senior developer, Tim, provides some insights into the overall architecture of the game and sends a quick snippet of code that he asks be used to enable a more consistent design across the entire game.
Based on this input, Sally realized that one of her original alternative solutions contains a flow diagram that illustrates Tim's proposed modification exactly.
She creates a copy of card \texttt{C5} and on this card (\texttt{C8}) she also copies the portion of card \texttt{C2} that is desired and combines it with the rest of the flow diagram.
To begin implementing the code, Sally creates another code editor card (\texttt{C9}) and begins coding up the solution she has outlined.
When she reaches the point at which Tim's proposed snippet of code is applicable, she quickly copies and pastes the code from card \texttt{C7} directly into card \texttt{C9}.

This example illustrates the process of \textit{collecting alternative solutions}, 
\textit{assessing the feasibility of the alternative solutions}, \textit{examining the applicability of the alternative solutions}, and finally \textit{recombining and consolidating the best aspects into a new solution}.

\section{Conclusions}
Our conclusions are ...


\section{Acknowledgements}
\bold{Add any NSF, OSU, UCI, etc. grants or funding references as needed.}

\bibliography{bibliography}
\bibliographystyle{apacite} 
\end{document}
