\documentclass{ppig}
\usepackage{epsfig}
\usepackage{booktabs}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}

% The titlebox defines how much vertical space is given for
% the authors' list. If you need extra space to show all the
% authors, uncomment the line below and increase the value. Please
% do not make the titlebox smaller than the original size of 5cm.
%\setlength\titlebox{5cm}

\title{Programming in a Problem-Solving Context: Are modern IDEs up to the task?}

% List the authors like you would in a table.
% The \And command creates another author's column. Use it after the
% details of one author to separate them from the following author horizontally.
% The \AND command creates a new "row" of authors and it should be used
% when the authors don't fit on the same line. You may have to increase
% the titlebox so that the author's don't overlap with the abstract.
\author{Nicholas Nelson \\
  Electrical Engineering \&\\ Computer Science \\
  Oregon State University \\
  nelsonni@oregonstate.edu \\
  \And
  Anita Sarma \\
  Electrical Engineering \&\\ Computer Science \\
  Oregon State University \\
  Anita.Sarma@oregonstate.edu \\
  \And
  Andr√© van der Hoek \\
  Department of Informatics \\
  University of California, Irvine \\
  andre@ics.uci.edu}

\date{\today}

% Packages and macros for editorial purposes. Not required for submission.
\usepackage{color}
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{ballblue}{rgb}{0.13, 0.67, 0.8}
\definecolor{aoblue}{rgb}{0.0, 0.0, 1.0}
\newcommand{\bold}[1]{\textit{\textbf{\color{aoblue}#1}}}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage{enumitem}

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{abstract}
Software development encompasses more than generating, testing, and maintaining code.
It is the manifestation of tools, skills, and techniques applied to problems that lend themselves to code-based solutions.
Contemporary IDEs natively support the code-centric aspects of software development, but forego providing direct support for many problem-solving traits such as constructing models, recalling prior knowledge, articulating \& refining alternatives, assessing application of alternatives, and recombining aspects of successful alternatives.

We... \bold{add contribution statements here.}
\end{abstract}

\bold{Section 1: scenario to illustrate programming as problem-solving\\
Section 2: introduction to column A of matrix, and details about a subset that we are focusing on in this paper\\
Section 3: challenges associated with current IDEs/problem-solving in programming\\
Section 4: envisioned solution (provide mockups and discussion about them)}

\section{Introduction}

Programming is in essence a problem solving task.
Let us take the example of a team of programmers developing healthcare software which must adhere to several data security and privacy regulations.
Healthcare software used in the United States must adhere to the Health Insurance Portability and Accountability Act (HIPAA), the Healthcare Reform Act of 2010


Lets take the example.... <walk through the steps and intimate why these are problem solving steps>

Often it also involves non-coding steps. For example....

However, current IDEs focus only on one aspect/slice of programming. Restricting...causing challenges 

We take a step back to understand the different aspects of programming and current support for these.

More specifically, we focus on x and y (from Col A) since these are the steps where tool support can be the most useful

We re-think the concept of IDE to involve a card metaphor, giving the user the flexibility....We present here mockups of our prototype.
We evaluated with our folks here and found, we did awesome 

\bold{3/22/2017 input from Andre:\\
We are exploring different IDEs based on this new paradigm of programming as problem-solving.
For this exploration, we are working on a cards-based environment.
This environment is our attempt at how we think an alternative environment would function...
}



Software development encompasses more than generating, testing, and maintaining code.
It is the application of tools, techniques, and knowledge applied to problems in a software domain.
These problems could be... \bold{add two example problems that highlight both "traditional" software problems, as well as non-code based problem-solving in this same space}

\bold{
Background regarding the problem-solving traits that are well supported by modern IDEs:
	\begin{itemize}[noitemsep, nolistsep]
	\item	Translating strategies to actions
	\item	Tracking progress
	\item	Evaluating and assessing change
	\item	Synchronization
	\item	...and others from PPS-Matrix
	\end{itemize}}
	
Not all aspects of problem-solving are as explicit as these, and in fact particular, it is the implicit elements of problem-solving that have less support from modern IDEs.

\bold{
Background regarding the problem-solving traits that are not well supported by modern IDEs:
	\begin{itemize}[noitemsep, nolistsep]
	\item	Articulating/refining alternatives
	\item	Recombining aspects of alternatives
	\item	Constructing models
	\item	Leveraging group knowledge
	\item	...and others from PPS-Matrix
	\end{itemize}}
	
Traditional IDEs are built for particular programming languages, use cases, and workflows.
Adding support for new languages and use cases to these IDEs increases UI complexity, but it does not cause a shift in the underlying design.
And for the sake of performance and consistency, uniformity is maintained across different UI components by tightly coupling the UI model with the IDE's internal infrastructure.
This coupling results in rigidity in the workflows allowed within a particular IDE.
Experimentation in alternative UI, workflow models, and use cases have higher intrinsic costs because of this IDE design mentality.

\section{Programming as Problem-Solving}
\bold{Add PPS-Matrix here and discuss column A}

\section{Challenges}
\bold{Weave references to Code Bubbles/Debugger Canvas and PatchWorks as part of the challenges discussions, since it is particularly relevant to our concepts.}

\bold{3/15/2017 input from Anita:
	\begin{itemize}[noitemsep, nolistsep]
	\item	C1: code centric
	\item	C2: not geared towards dynamic exploration / backtracking / breadcrumbs
	\subitem C1.1: past history
	\subitem C1.2: immediate past exploration
	\subitem C1.3: Outside resources
	\item	C3: evaluate options (side-by-side)
	\item	C4: flexible to match individual's programming preferences
	\item	C5: currently only code is considered 1st class; consider all pieces equivalent
	\subitem based on context of current work, diff aspects of project might take precedence
	\end{itemize}
}

\bold{
Modern IDEs don't support all problem-solving aspects.
	\begin{itemize}[noitemsep, nolistsep]
	\item	IDEs are highly-coupled to a code-centric metaphor of software development.
	\item	IDEs are built around workflows that fit for only certain languages (ex: Java-specific for Eclipse/IntelliJ).
	\item	IDEs are NOT general-purpose programming environments (ex: RStudio, PyCharm, etc.).
	\item	The UI layer is dictated by both the target programming language and the typical use-case (see point above).
	\item	Experimentation in UI design, and by association certain workflows, are not supported by most IDEs.
	\item	Problem-solving tasks unrelated to code are typically banished to plugins or not supported at all.
	\end{itemize}}

\section{Tenjin IDE}
To address these challenges, we present Tenjin IDE, an integrated development environment for problem-solving in software development.
The goal of Tenjin IDE is to offer developers: a cards-based interface for organizing and searching artifacts based on changing requirements, and an extensible catalog of card UI elements that can easily accommodate new use-cases and behaviors.
This approach provides developers with a framework for adapting their IDE to suit their desired configuration, instead of adapting their processes to compensate for it.

\subsection{Cards}
\fbox{\includegraphics[trim={1.3cm 1.7cm 1.7cm 1.5cm},clip,width=\textwidth]{Mockup-5}}
\bold{Discussion of elements in the code card figure above.}

\bold{FIGURE: Front and back of a non-code card (web-search results?).}
\bold{Discussion of elements in the non-code card figure above.}

\bold{
Cards have the following properties:
	\begin{itemize}[noitemsep, nolistsep]
	\item 	Moveable anywhere across the IDE canvas window.
	\item 	Individual cards are not resizable, however user settings should allow for increasing the default size of all cards.
	\item 	Each card allows for the expansion to a full-screen mode to accommodate editing the entire content of a cards (since cards are likely to be too small of an editable workspace).
	\item 	Discussion about the meta-data contained on the reverse of a card.
	\item 	Use examples of a code-based card (OO languages lend themselves to cards in the easiest to understand manner), and also non-code cards such as developer notes from a meeting (i.e. informal requirements) and web-search results from StackOverflow (answers with code references for better applicability).
	\end{itemize}
}

\subsection{Canvas}
\bold{FIGURE: Basic canvas with a few cards in both stacked and fully-exposed sets, as well as a few unorganized cards.}
\bold{Discussion of the different organizational elements in the figure above.}

\bold{
Canvas has the following properties:
	\begin{itemize}[noitemsep,nolistsep]
		\item	Size is infinite in all directions.
		\item	Cards cannot be farther than 1-screen distance from any other cards; prevents losing cards in the ether of infinite area.
		\item	Cards can be stacked in piles throughout the canvas.
		\item	Filtering allows new groupings (stacks, hand of cards, or fully-exposed set) based upon user-defined criteria.
		\item	Filtering criteria could include: most recent, only cards edited by Joe, only cards not currently pushed to a non-local version control system, all cards that contained errors according to the last compilation/build/execution attempt, etc.
		\item	Search allows cards to remain where they have been placed, but assists the user in navigating to that particular location (via card highlighting, or some similar UI element).
	\end{itemize}
}

\section{Conclusions}
Our conclusions are ...


\section{Acknowledgements}
\bold{Add any NSF, OSU, UCI, etc. grants or funding references as needed.}

\bibliography{bibliography}
\bibliographystyle{apacite} 
\end{document}
